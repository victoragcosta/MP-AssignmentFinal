        -:    0:Source:transaction.c
        -:    0:Graph:transaction.gcno
        -:    0:Data:transaction.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:// Módulo de transações.
        -:    2:
        -:    3:/**
        -:    4: * @file transaction.c
        -:    5: * @brief Implementação do módulo de transações.
        -:    6: */
        -:    7:
        -:    8:#include "transaction.h"
        -:    9:
        7:   10:errorLevel CancelTransaction(transaction *target_transaction) {
        -:   11:
        -:   12:  /*
        -:   13:    Uma transação só pode ser cancelada se o seu status é Open ou InProgress,
        -:   14:    pois não faz sentido cancelar transações já finalizadas (status = Closed),
        -:   15:    transações já canceladas (status = Canceled) ou transações que geraram erros
        -:   16:    (status = Error).
        -:   17:   */
        -:   18:
        7:   19:  if(target_transaction == NULL || (target_transaction->status != Open
        4:   20:     && target_transaction->status != InProgress))
        4:   21:    return Illegal_argument;
        -:   22:
        3:   23:  target_transaction->status = Canceled;
        -:   24:
        3:   25:  return Success;
        -:   26:
        -:   27:}
        -:   28:
        -:   29:/**
        -:   30: * @fn errorLevel CopyTransaction(transaction *copy, transaction *original)
        -:   31: * @brief Função que copia uma transação.
        -:   32: * @param copy Endereço da transação que receberá as especificações copiadas.
        -:   33: * Argumento passado por referência.
        -:   34: * @param original Endereço da transação que será copiada.
        -:   35: * Argumento passado por referência.
        -:   36: * @return A função retorna uma instância do tipo errorLevel: Success caso a
        -:   37: * transação seja copiada com sucesso; Illegal_argument caso um dos argumentos
        -:   38: * passados seja um ponteiro nulo.
        -:   39: *
        -:   40: * Copia os dados de uma transação para outra transação.
        -:   41: *
        -:   42: * Assertivas de entrada:
        -:   43: *  -Ambos copy e original devem ser diferentes de NULL.
        -:   44: *  -Ambos copy e original devem apontar para estruturas de dados do tipo
        -:   45: *   transaction.
        -:   46: *
        -:   47: * Assertivas de saída:
        -:   48: *  -Os parâmetros da transação no endereço copy serão os mesmos que os
        -:   49: * parâmetros da transação no endereço original.
        -:   50: *
        -:   51: * Assertivas estruturais:
        -:   52: *  -Uma estrutura de dados transaction possui como membros um unsigned int para
        -:   53: * o primeiro usuário envolvido na transação, um unsigned int para o segundo
        -:   54: * usuário envolvido na transação, uma estrutura de dados do tipo product para o
        -:   55: * produto que está sendo transacionado e uma estrutura de dados do tipo
        -:   56: * transactionStatus para seu estado.
        -:   57: *
        -:   58: * Assertivas de contrato:
        -:   59: *  -As informações contidas no endereço copy serão sobrescritas pelas
        -:   60: * informações contidas no endereço original.
        -:   61: *
        -:   62: * Requisitos:
        -:   63: *  -Duas estruturas de dados do tipo transaction alocadas estaticamente.
        -:   64: *
        -:   65: * Hipóteses:
        -:   66: *  Nenhuma.
        -:   67: */
        -:   68:
        9:   69:errorLevel CopyTransaction(transaction *copy, transaction *original) {
        -:   70:
        9:   71:  if(copy == NULL || original == NULL)
        3:   72:    return Illegal_argument;
        -:   73:
        6:   74:  copy->user1 = original->user1;
        6:   75:  copy->user2 = original->user2;
        6:   76:  copy->status = original->status;
        6:   77:  CopyProduct(&(copy->item), &(original->item));
        -:   78:
        6:   79:  return Success;
        -:   80:
        -:   81:}
        -:   82:
       17:   83:errorLevel CreateTransaction(unsigned int user_id1, unsigned int user_id2,
        -:   84:                             product *item, transactionStatus status,
        -:   85:                             transaction *new_transaction) {
        -:   86:
       32:   87:  if(item == NULL || new_transaction == NULL
       31:   88:     || (ValidTransactionArguments(user_id1, user_id2, item, status) != 1))
       12:   89:    return Illegal_argument;
        -:   90:
        5:   91:  new_transaction->user1 = user_id1;
        5:   92:  new_transaction->user2 = user_id2;
        5:   93:  new_transaction->status = status;
        5:   94:  CopyProduct(&(new_transaction->item), item);
        -:   95:
        5:   96:  return Success;
        -:   97:
        -:   98:}
        -:   99:
       15:  100:errorLevel FinishTransaction(
        -:  101:    transaction *given_transaction,
        -:  102:    unsigned int grade1,
        -:  103:    unsigned int grade2,
        -:  104:    char comment1[AVALIACAO_LIMITE_COMENTARIO],
        -:  105:    char comment2[AVALIACAO_LIMITE_COMENTARIO]) {
        -:  106:
        -:  107:  /*
        -:  108:    Uma transação só pode ser finalizada caso seu status seja InProgress e caso
        -:  109:    os argumentos fornecidos para a função sejam válidos.
        -:  110:  .*/
        -:  111:
       28:  112:  if(given_transaction == NULL || comment1 == NULL || comment2 == NULL
       11:  113:     || (ValidTransaction(given_transaction) != 1)
        8:  114:     || given_transaction->status != InProgress || !ValidGrade(grade1)
       18:  115:     || !ValidGrade(grade2))
       13:  116:    return Illegal_argument;
        -:  117:
        -:  118:  /*
        -:  119:    Para que uma transação seja finalizada, os usuários que participaram da
        -:  120:    transação devem se avaliar. Caso não seja possível realizar as avaliações
        -:  121:    entre os usuários, diz-se que a finalização de transação falhou.
        -:  122:   */
        -:  123:
        4:  124:  if(avaliacao_avaliar(given_transaction->user1, given_transaction->user2,
        -:  125:                       grade1, comment1) != AVALIACAO_SUCESSO
        2:  126:     || avaliacao_avaliar(given_transaction->user2, given_transaction->user1,
        -:  127:                          grade2, comment2) != AVALIACAO_SUCESSO)
    #####:  128:    return Failure;
        -:  129:
        -:  130:  /*
        -:  131:    Somente caso as avaliações sejam feitas com sucesso é que se atribui o
        -:  132:    status "Closed" para a transação.
        -:  133:   */
        -:  134:
        2:  135:  given_transaction->status = Closed;
        -:  136:
        2:  137:  return Success;
        -:  138:
        -:  139:}
        -:  140:
       17:  141:errorLevel StartTransaction(unsigned int user_id, product *item,
        -:  142:                             transaction *new_transaction) {
        -:  143:
       32:  144:  if(item == NULL || new_transaction == NULL || (ValidProduct(item) != 1)
       30:  145:     || user_id == 0)
        4:  146:    return Illegal_argument;
        -:  147:
        -:  148:  /*
        -:  149:    Em uma transação aberta, há apenas um usuário presente, esperando outro
        -:  150:    usuário envolver-se na transação. Entretanto, a função possui dois campos
        -:  151:    para id de usuário. Para resolver esse problema, copia-se o id do único
        -:  152:    usuário presente na transação nos dois campos. Por esse motivo, uma
        -:  153:    transação de status "Open" sempre deve ter os campos user1 e user2 iguais.
        -:  154:    Do contrário, a transação não será válida.
        -:  155:   */
        -:  156:
       13:  157:  new_transaction->user1 = user_id;
       13:  158:  new_transaction->user2 = user_id;
       13:  159:  new_transaction->status = Open;
       13:  160:  CopyProduct(&(new_transaction->item), item);
        -:  161:
       13:  162:  return Success;
        -:  163:
        -:  164:}
        -:  165:
       13:  166:errorLevel UpdateTransaction(unsigned int user_id,
        -:  167:                             transaction *started_transaction) {
        -:  168:
        -:  169:  /*
        -:  170:    Só se pode atualizar transações de status "Open" e nunca pode-se fazê-lo com
        -:  171:    o mesmo usuário que já estava na transação ou com o id 0, por ser um id de
        -:  172:    usuário inválido nesse contexto.
        -:  173:   */
        -:  174:
       13:  175:  if(started_transaction == NULL || started_transaction->status != Open
        9:  176:     || user_id == started_transaction->user1 || user_id == 0)
        6:  177:    return Illegal_argument;
        -:  178:
        -:  179:  /*
        -:  180:    Para atualizar uma transação, modifica-se o segundo usuário da transação e
        -:  181:    atribui-se a ela o status "InProgress".
        -:  182:   */
        -:  183:
        7:  184:  started_transaction->user2 = user_id;
        7:  185:  started_transaction->status = InProgress;
        -:  186:
        7:  187:  return Success;
        -:  188:
        -:  189:}
        -:  190:
        -:  191:/**
        -:  192: * @fn int CompareTransactions(transaction *first, transaction *second)
        -:  193: * @brief Função que compara duas transações.
        -:  194: * @param first Endereço da primeira transação que faz parte da comparação.
        -:  195: * Argumento passado por referência.
        -:  196: * @param second Endereço da segunda transação que faz parte da comparação.
        -:  197: * Argumento passado por referência.
        -:  198: * @return A função retorna -1 caso algum dos argumentos seja um ponteiro nulo,
        -:  199: * 0 caso as transações sejam iguais e 1 caso sejam diferentes.
        -:  200: *
        -:  201: * Verifica se todos os campos de duas estruturas de dados do tipo transaction
        -:  202: * são iguais. Compara-se manualmente cada campo das duas transações.
        -:  203: *
        -:  204: * Assertivas de entrada:
        -:  205: *  -Ambas first e second devem ser diferentes de NULL.
        -:  206: *  -Ambas first e second devem apontar para estruturas de dados do tipo
        -:  207: *   transaction.
        -:  208: *
        -:  209: * Assertivas de saída:
        -:  210: *  -Os parâmetros da transação no endereço first e second estarão inalterados.
        -:  211: *
        -:  212: * Assertivas estruturais:
        -:  213: *  -Uma estrutura de dados transaction possui como membros um unsigned int para
        -:  214: * o primeiro usuário envolvido na transação, um unsigned int para o segundo
        -:  215: * usuário envolvido na transação, uma estrutura de dados do tipo product para o
        -:  216: * produto que está sendo transacionado e uma estrutura de dados do tipo
        -:  217: * transactionStatus para seu estado.
        -:  218: *
        -:  219: * Assertivas de contrato:
        -:  220: *  -A função retornará um inteiro representando se as transações são iguais ou
        -:  221: * não ou se os parâmetros passados são ilegais, sem alterar as transações em
        -:  222: * si.
        -:  223: *
        -:  224: * Requisitos:
        -:  225: *  -Duas estruturas de dados do tipo transaction alocadas estaticamente.
        -:  226: *
        -:  227: * Hipóteses:
        -:  228: *  Nenhuma.
        -:  229: *
        -:  230: */
        -:  231:
       14:  232:int CompareTransactions(transaction *first, transaction *second) {
        -:  233:
       14:  234:  if(first == NULL || second == NULL)
        3:  235:    return -1;
        -:  236:
        -:  237:  /*
        -:  238:    Verifica-se individualmente se cada um dos campos das 2 transações são
        -:  239:    iguais.
        -:  240:   */
        -:  241:
       31:  242:  else if(first->user1 == second->user1 && first->user2 == second->user2
        7:  243:     && first->status == second->status
       16:  244:     && !CompareProducts(&(first->item), &(second->item)))
        3:  245:    return 0;
        -:  246:
        -:  247:  else
        8:  248:    return 1;
        -:  249:
        -:  250:}
        -:  251:
        -:  252:/**
        -:  253: * @fn int ConvertIntToTransactionStatus(int number, transactionStatus *status)
        -:  254: * @brief Função que converte um inteiro para um estado de transação.
        -:  255: * @param number Número convertido.
        -:  256: * @param status Endereço de variável do tipo transactionStatus que recebe o
        -:  257: * resultado da conversão.
        -:  258: * @return A função retorna um inteiro: 0 se a conversão foi bem sucedida; -1 se
        -:  259: * a função recebeu um ponteiro NULL como argumento.
        -:  260: *
        -:  261: * Realiza a conversão de um número inteiro para seu respectivo estado de
        -:  262: * transação contido na enumeração transactionStatus e atribui esse resultado
        -:  263: * para a estrutura de dados transactionStatus no endereço status. Caso o número
        -:  264: * não represente um transactionStatus válido, será atribuído o
        -:  265: * transactionStatus "Error".
        -:  266: *
        -:  267: * Assertivas de entrada:
        -:  268: *  -status != NULL.
        -:  269: *  -status aponta para uma estrutura de dados do tipo transactionStatus.
        -:  270: *
        -:  271: * Assertivas de saída:
        -:  272: *  -O estado de transação contido em status será equivalente ao estado de
        -:  273: * transação representado por number.
        -:  274: *
        -:  275: * Assertivas estruturais:
        -:  276: *  -Um estrutura de dados do tipo transactionStatus equivale a "Open,
        -:  277: * "InProgress", "Closed", "Canceled" ou "Error".
        -:  278: *
        -:  279: * Assertivas de contrato:
        -:  280: *  -A função sobrescreverá o estado de transação contido no endereço status com
        -:  281: * o estado de transação obtido na conversão do inteiro number para um estado de
        -:  282: * transação.
        -:  283: *
        -:  284: * Requisitos:
        -:  285: *  -Uma estrutura de dados do tipo transactionStatus alocada estaticamente.
        -:  286: *
        -:  287: * Hipóteses:
        -:  288: *  Nenhuma.
        -:  289: *
        -:  290: */
        -:  291:
        6:  292:int ConvertIntToTransactionStatus(int number, transactionStatus *status) {
        -:  293:
        6:  294:  if(status == NULL)
        1:  295:    return -1;
        -:  296:
        5:  297:  switch (number) {
        -:  298:
        1:  299:    case 0:
        1:  300:      *status = Open;
        1:  301:      break;
        -:  302:
        1:  303:    case 1:
        1:  304:      *status = InProgress;
        1:  305:      break;
        -:  306:
        1:  307:    case 2:
        1:  308:      *status = Closed;
        1:  309:      break;
        -:  310:
        1:  311:    case 3:
        1:  312:      *status = Canceled;
        1:  313:      break;
        -:  314:
        1:  315:    default:
        1:  316:      *status = Error;
        -:  317:
        -:  318:  }
        -:  319:
        5:  320:  return 0;
        -:  321:
        -:  322:}
        -:  323:
        -:  324:/**
        -:  325: * @fn int ValidGrade (unsigned int grade)
        -:  326: * @brief Função que verifica se uma nota é válida.
        -:  327: * @param grade Nota testada.
        -:  328: * @return A função retorna um inteiro: 1 se a nota é válida; 0 se a nota é
        -:  329: * inválida.
        -:  330: *
        -:  331: * Verifica se uma está contida no intervalo de notas válidas definido
        -:  332: * previamente.
        -:  333: *
        -:  334: * Assertivas de entrada:
        -:  335: *  Nenhuma.
        -:  336: *
        -:  337: * Assertivas de saída:
        -:  338: *  Nenhuma.
        -:  339: *
        -:  340: * Assertivas estruturais:
        -:  341: *  Nenhuma.
        -:  342: *
        -:  343: * Assertivas de contrato:
        -:  344: *  -A função retornará um inteiro representando se a nota passada como
        -:  345: * parâmetro pode ser usado como nota em uma avaliação ou não.
        -:  346: *
        -:  347: * Requisitos:
        -:  348: *  Nenhum.
        -:  349: *
        -:  350: * Hipóteses:
        -:  351: *  Nenhuma.
        -:  352: *
        -:  353: */
        -:  354:
        8:  355:int ValidGrade (unsigned int grade) {
        -:  356:
        -:  357:  /* As notas de avaliação válida variam de 0 a 5. */
        -:  358:
        8:  359:  if(grade <= 5)
        5:  360:    return 1;
        -:  361:
        -:  362:  else
        3:  363:    return 0;
        -:  364:
        -:  365:}
        -:  366:
        -:  367:/**
        -:  368: * @fn int ValidTransaction (transaction *given_transaction)
        -:  369: * @brief Função que verifica se uma transação é válida.
        -:  370: * @param given_transaction Endereço da transação que será testada. Argumento
        -:  371: * passado por referência.
        -:  372: * @return A função retorna um inteiro: 1 se a transação é válida; 0 se a
        -:  373: * transação é inválida.
        -:  374: *
        -:  375: * Verifica se uma transação contém os parâmetros usuário 01, usuário 02,
        -:  376: * produto e estado válidos conforme métricas definidas previamente. Faz-se isso
        -:  377: * passando-se os parâmetros da transação para a função
        -:  378: * ValidTransactionArguments.
        -:  379: *
        -:  380: * Assertivas de entrada:
        -:  381: *  -O parâmetro given_transaction deve ser diferente de NULL.
        -:  382: *  -O parâmetro given_transaction deve apontar para uma estrutura de dados do
        -:  383: * tipo transaction.
        -:  384: *
        -:  385: * Assertivas de saída:
        -:  386: *  -Os parâmetros da transação no endereço given_transaction permanecerão
        -:  387: * inalterados.
        -:  388: *
        -:  389: * Assertivas estruturais:
        -:  390: *  -Uma estrutura de dados transaction possui como membros um unsigned int para
        -:  391: * o primeiro usuário envolvido na transação, um unsigned int para o segundo
        -:  392: * usuário envolvido na transação, uma estrutura de dados do tipo product para o
        -:  393: * produto que está sendo transacionado e uma estrutura de dados do tipo
        -:  394: * transactionStatus para seu estado.
        -:  395: *
        -:  396: * Assertivas de contrato:
        -:  397: *  -A função retornará um inteiro representando se a transação cujo endereço
        -:  398: * foi passado como parâmetro contém seus membros válidos ou não ou se o
        -:  399: * parâmetro fornecido para a função ValidTransaction é inválido.
        -:  400: *
        -:  401: * Requisitos:
        -:  402: *  -Uma estrutura de dados do tipo transaction alocada estaticamente.
        -:  403: *
        -:  404: * Hipóteses:
        -:  405: *  Nenhuma.
        -:  406: *
        -:  407: */
        -:  408:
       11:  409:int ValidTransaction (transaction *given_transaction) {
        -:  410:
       11:  411:  if(given_transaction == NULL)
    #####:  412:    return -1;
        -:  413:
       22:  414:  else if(ValidTransactionArguments(given_transaction->user1,
        -:  415:          given_transaction->user2, &(given_transaction->item),
       11:  416:          given_transaction->status) != 1)
        3:  417:    return 0;
        -:  418:
        -:  419:  else
        8:  420:    return 1;
        -:  421:
        -:  422:}
        -:  423:
       25:  424:int ValidTransactionArguments(unsigned int user1, unsigned int user2,
        -:  425:                              product *item, transactionStatus status) {
        -:  426:
       25:  427:  if(item == NULL)
    #####:  428:    return -1;
        -:  429:
        -:  430:  /*
        -:  431:    Algums comentários para melhor compreensão do condicional abaixo:
        -:  432:      -Os únicos estados de transação que permitem que os 2 ids de usuários da
        -:  433:      transação sejam iguais são "Open" e "Canceled", pois uma transação cujo
        -:  434:      estado é "Open" aguarda a chegada de um segundo usuário e uma transação
        -:  435:      cujo estado é "Canceled" pode ter sido gerada a partir de uma transação
        -:  436:      cujo estado era "Open".
        -:  437:      -Pela definição de uma transação de estado "Open" feita acima, os 2 ids de
        -:  438:      usuários de uma transação cujo estado é "Open" devem ser necessáriamente
        -:  439:      iguais.
        -:  440:      -O id de usuário 0 está reservado para conter os dados do usuário logado
        -:  441:      no momento, não podendo, portanto, ser o argumento de uma transação.
        -:  442:   */
        -:  443:
       73:  444:  else if((ValidProduct(item) != 1) || status == Error
       21:  445:          || (user1 == user2 && (status != Open && status != Canceled))
       43:  446:          || (user1 != user2 && status == Open) || user1 == 0 || user2 == 0)
       12:  447:    return 0;
        -:  448:
        -:  449:  else
       13:  450:    return 1;
        -:  451:
        -:  452:}
