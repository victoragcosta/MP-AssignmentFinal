        -:    0:Source:product.c
        -:    0:Graph:product.gcno
        -:    0:Data:product.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:// Módulo de produtos.
        -:    2:
        -:    3:/**
        -:    4: * @file product.c
        -:    5: * @brief Implementação do módulo de produtos.
        -:    6: */
        -:    7:
        -:    8:#include "product.h"
        -:    9:
        -:   10:/**
        -:   11: * @fn errorLevel CopyProduct(product *copy, product *original)
        -:   12: * @brief Função que copia um produto.
        -:   13: * @param copy Endereço do produto que receberá as especificações copiadas.
        -:   14: * Argumento passado por referência.
        -:   15: * @param original Endereço do produto que será copiado.
        -:   16: * Argumento passado por referência.
        -:   17: * @return A função retorna uma instância do tipo errorLevel: Success caso o
        -:   18: * produto seja copiado com sucesso; Illegal_argument caso um dos argumentos
        -:   19: * passados seja um ponteiro nulo.
        -:   20: *
        -:   21: * Copia os dados de um produto para outro produto.
        -:   22: *
        -:   23: * Assertivas de entrada:
        -:   24: *  -Ambos copy e original devem ser diferentes de NULL.
        -:   25: *  -Ambos copy e original devem apontar para estruturas de dados do tipo
        -:   26: *   product.
        -:   27: *
        -:   28: * Assertivas de saída:
        -:   29: *  -Os parâmetros do produto no endereço copy serão os mesmos que os parâmetros
        -:   30: * do produto no endereço original.
        -:   31: *
        -:   32: * Assertivas estruturais:
        -:   33: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:   34: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:   35: * para seu preço e um int para sua popularidade.
        -:   36: *
        -:   37: * Assertivas de contrato:
        -:   38: *  -As informações contidas no endereço copy serão sobrescritas pelas
        -:   39: * informações contidas no endereço original.
        -:   40: *
        -:   41: * Requisitos:
        -:   42: *  -Duas estruturas de dados do tipo product alocadas estaticamente.
        -:   43: *
        -:   44: * Hipóteses:
        -:   45: *  Nenhuma.
        -:   46: *
        -:   47: */
        -:   48:
        8:   49:errorLevel CopyProduct(product *copy, product *original) {
        -:   50:
        8:   51:  if(copy == NULL || original == NULL)
        4:   52:    return Illegal_argument;
        -:   53:
        4:   54:  strcpy(copy->name, original->name);
        4:   55:  copy->type = original->type;
        4:   56:  copy->price = original->price;
        4:   57:  copy->popularity = original->popularity;
        -:   58:
        4:   59:  return Success;
        -:   60:
        -:   61:}
        -:   62:
        -:   63:/**
        -:   64: * @fn errorLevel CreateProduct(char name[75], productType type, double price,
        -:   65: * int popularity, product *new_product)
        -:   66: * @brief Função que cria um produto.
        -:   67: * @param name Nome do produto a ser criado.
        -:   68: * @param type Tipo do produto a ser criado.
        -:   69: * @param price Preço do produto a ser criado.
        -:   70: * @param popularity Popularidade do produto a ser criado.
        -:   71: * @param new_product Endereço da estrutura de dados onde o produto será
        -:   72: * criado. Argumento passado por referência.
        -:   73: * @return A função retorna uma instância do tipo errorLevel: Success caso o
        -:   74: * produto seja criado com sucesso; Illegal_argument caso os parâmetros
        -:   75: * passados para a criação do produto sejam inválidos ou caso um dos produtos
        -:   76: * passados seja um ponteiro nulo.
        -:   77: *
        -:   78: * Atualiza os dados de uma estrutura de dados do tipo product a partir de uma
        -:   79: * string, uma estrutura de dados do tipo productType, um double e um int. Os
        -:   80: * dados em new_product são sobrescritos com os dados fornecidos como parâmetros
        -:   81: * da função.
        -:   82: *
        -:   83: * Assertivas de entrada:
        -:   84: *  -O parâmetro new_product deve ser diferente de NULL.
        -:   85: *  -O parâmetro new_product deve apontar para uma estrutura de dados do tipo
        -:   86: * product.
        -:   87: *
        -:   88: * Assertivas de saída:
        -:   89: *  -Os membros do produto no endereço new_product serão aqueles passados como
        -:   90: * parâmetros para a função.
        -:   91: *
        -:   92: * Assertivas estruturais:
        -:   93: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:   94: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:   95: * para seu preço e um int para sua popularidade.
        -:   96: *
        -:   97: * Assertivas de contrato:
        -:   98: *  -As informações contidas no endereço new_product serão sobrescritas pelas
        -:   99: * informações passadas como parâmetros da função.
        -:  100: *
        -:  101: * Requisitos:
        -:  102: *  -Uma estrutura de dados do tipo product alocada estaticamente.
        -:  103: *
        -:  104: * Hipóteses:
        -:  105: *  Nenhuma.
        -:  106: *
        -:  107: */
        -:  108:
       34:  109:errorLevel CreateProduct(char name[75], productType type, double price,
        -:  110:int popularity, product *new_product) {
        -:  111:
       34:  112:  if(new_product == NULL || !ValidPrice(price) || !ValidPopularity(popularity))
       10:  113:    return Illegal_argument;
        -:  114:
       24:  115:  strcpy(new_product->name, name);
       24:  116:  new_product->type = type;
       24:  117:  new_product->price = price;
       24:  118:  new_product->popularity = popularity;
        -:  119:
       24:  120:  return Success;
        -:  121:
        -:  122:}
        -:  123:
        -:  124:/**
        -:  125: * @fn int CompareProducts(product *first, product *second)
        -:  126: * @brief Função que compara dois produtos.
        -:  127: * @param first Endereço do primeiro produto que faz parte da comparação.
        -:  128: * Argumento passado por referência.
        -:  129: * @param second Endereço do segundo produto que faz parte da comparação.
        -:  130: * Argumento passado por referência.
        -:  131: * @return A função retorna -1 caso algum dos argumentos seja um ponteiro nulo,
        -:  132: * 0 caso os produtos sejam iguais e 1 caso sejam diferentes.
        -:  133: *
        -:  134: * Verifica se todos os campos de duas estruturas de dados do tipo product são
        -:  135: * iguais. Compara-se manualmente cada campo dos dois produtos.
        -:  136: *
        -:  137: * Assertivas de entrada:
        -:  138: *  -Ambos first e second devem ser diferentes de NULL.
        -:  139: *  -Ambos first e second devem apontar para estruturas de dados do tipo
        -:  140: *   product.
        -:  141: *
        -:  142: * Assertivas de saída:
        -:  143: *  -Os parâmetros do produto no endereço first e second estarão inalterados.
        -:  144: *
        -:  145: * Assertivas estruturais:
        -:  146: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:  147: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:  148: * para seu preço e um int para sua popularidade.
        -:  149: *
        -:  150: * Assertivas de contrato:
        -:  151: *  -A função retornará um inteiro representando se os produtos são iguais ou
        -:  152: * não ou se os parâmetros passados são ilegais, sem alterar os produtos em si.
        -:  153: *
        -:  154: * Requisitos:
        -:  155: *  -Duas estruturas de dados do tipo product alocadas estaticamente.
        -:  156: *
        -:  157: * Hipóteses:
        -:  158: *  Nenhuma.
        -:  159: */
        -:  160:
       28:  161:int CompareProducts(product *first, product *second) {
        -:  162:
       28:  163:  if(first == NULL || second == NULL)
        6:  164:    return -1;
        -:  165:
        -:  166:  /*
        -:  167:    Verifica-se individualmente se cada um dos campos dos 2 produtos são iguais.
        -:  168:   */
        -:  169:
       22:  170:  else if(!strcmp(first->name, second->name)
       18:  171:     && first->type == second->type
       14:  172:     && first->price == second->price
       10:  173:     && first->popularity == second->popularity)
        6:  174:    return 0;
        -:  175:
        -:  176:  else
       16:  177:    return 1;
        -:  178:
        -:  179:}
        -:  180:
        -:  181:/**
        -:  182: * @fn ValidPrice(double price)
        -:  183: * @brief Função que verifica se um preço é válido.
        -:  184: * @param price Preço testado.
        -:  185: * @return A função retorna um inteiro: 1 se o preço é válido; 0 se o preço é
        -:  186: * inválido.
        -:  187: *
        -:  188: * Verifica se um preço está contido no intervalo de preços válidos definido
        -:  189: * previamente.
        -:  190: *
        -:  191: * Assertivas de entrada:
        -:  192: *  Nenhuma.
        -:  193: *
        -:  194: * Assertivas de saída:
        -:  195: *  Nenhuma.
        -:  196: *
        -:  197: * Assertivas estruturais:
        -:  198: *  Nenhuma.
        -:  199: *
        -:  200: * Assertivas de contrato:
        -:  201: *  -A função retornará um inteiro representando se o preço passado como
        -:  202: * parâmetro pode ser usado como preço de produto ou não.
        -:  203: *
        -:  204: * Requisitos:
        -:  205: *  Nenhum.
        -:  206: *
        -:  207: * Hipóteses:
        -:  208: *  Nenhuma.
        -:  209: *
        -:  210: */
        -:  211:
       38:  212:int ValidPrice(double price) {
        -:  213:
        -:  214:  /* Um produto não pode ter seu preço negativo ou maior que 1.000.000,00. */
        -:  215:
       38:  216:  if(price > 0 && price <= 1000000)
       32:  217:    return 1;
        -:  218:
        -:  219:  else
        6:  220:    return 0;
        -:  221:
        -:  222:}
        -:  223:
        -:  224:/**
        -:  225: * @fn ValidPopularity(int popularity)
        -:  226: * @brief Função que verifica se uma popularidade é válida.
        -:  227: * @param popularity Popularidade testada.
        -:  228: * @return A função retorna um inteiro: 1 se a popularidade é válida e 0 se a
        -:  229: * popularidade é inválida.
        -:  230: *
        -:  231: * Verifica se uma popularidade está contido no intervalo de popularidades
        -:  232: * válidas definido previamente.
        -:  233: *
        -:  234: * Assertivas de entrada:
        -:  235: *  Nenhuma.
        -:  236: *
        -:  237: * Assertivas de saída:
        -:  238: *  Nenhuma.
        -:  239: *
        -:  240: * Assertivas estruturais:
        -:  241: *  Nenhuma.
        -:  242: *
        -:  243: * Assertivas de contrato:
        -:  244: *  -A função retornará um inteiro representando se a popularidade passada como
        -:  245: * parâmetro pode ser usada como popularidade de produto ou não.
        -:  246: *
        -:  247: * Requisitos:
        -:  248: *  Nenhum.
        -:  249: *
        -:  250: * Hipóteses:
        -:  251: *  Nenhuma.
        -:  252: *
        -:  253: */
        -:  254:
       32:  255:int ValidPopularity(int popularity) {
        -:  256:
        -:  257:  /* Um produto não pode ter sua popularidade negativa ou maior que 100. */
        -:  258:
       32:  259:  if(popularity >= 0 && popularity <= 100)
       26:  260:    return 1;
        -:  261:
        -:  262:  else
        6:  263:    return 0;
        -:  264:
        -:  265:}
        -:  266:
        -:  267:/**
        -:  268: * @fn ValidProduct(product *item)
        -:  269: * @brief Função que verifica se um produto é válido.
        -:  270: * @param item Endereço do produto que será testado. Argumento passado por
        -:  271: * referência.
        -:  272: * @return A função retorna um inteiro: 1 se o produto é válido; 0 se o produto
        -:  273: * é inválido.
        -:  274: *
        -:  275: * Verifica se um produto contém os parâmetros preço e popularidade válidos
        -:  276: * conforme intervalos definidos previamente. Faz-se isso passando-se o preço
        -:  277: * e a popularidade do produto para as funções ValidPrice e ValidPopularity,
        -:  278: * respectivamente.
        -:  279: *
        -:  280: * Assertivas de entrada:
        -:  281: *  -O parâmetro item deve ser diferente de NULL.
        -:  282: *  -O parâmetro item deve apontar para uma estrutura de dados do tipo
        -:  283: * product.
        -:  284: *
        -:  285: * Assertivas de saída:
        -:  286: *  -Os parâmetros do produto no endereço item permanecerão inalterados.
        -:  287: *
        -:  288: * Assertivas estruturais:
        -:  289: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:  290: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:  291: * para seu preço e um int para sua popularidade.
        -:  292: *
        -:  293: * Assertivas de contrato:
        -:  294: *  -A função retornará um inteiro representando se a produto cujo endereço foi
        -:  295: * passado como parâmetro contém os membros preço e popularidade válidos ou não
        -:  296: * ou se o parâmetro fornecido é inválido.
        -:  297: *
        -:  298: * Requisitos:
        -:  299: *  -Uma estrutura de dados do tipo product alocada estaticamente.
        -:  300: *
        -:  301: * Hipóteses:
        -:  302: *  Nenhuma.
        -:  303: *
        -:  304: */
        -:  305:
        8:  306:int ValidProduct(product *item) {
        -:  307:
        8:  308:  if(item == NULL)
        2:  309:    return -1;
        -:  310:
        6:  311:  else if(ValidPrice(item->price) && ValidPopularity(item->popularity))
        2:  312:    return 1;
        -:  313:
        -:  314:  else
        4:  315:    return 0;
        -:  316:
        -:  317:}
