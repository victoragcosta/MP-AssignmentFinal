        -:    0:Source:product_search.c
        -:    0:Graph:product_search.gcno
        -:    0:Data:product_search.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:// Módulo de pesquisa de produtos.
        -:    2:
        -:    3:/**
        -:    4: * @file product_search.c
        -:    5: * @brief Implementação do módulo de pesquisa de produtos.
        -:    6: */
        -:    7:
        -:    8:#include "product_search.h"
        -:    9:
        -:   10:/**
        -:   11: * @fn errorLevel AddProduct(product *new_product, productList *list)
        -:   12: * @brief Função que adiciona um produto à uma lista de produtos.
        -:   13: * @param new_product Endereço do produto a ser adicionado. Argumento passado
        -:   14: * por referência.
        -:   15: * @param list Endereço da lista que receberá o produto. Argumento passado por
        -:   16: * referência.
        -:   17: * @return A função retorna uma instância do tipo errorLevel: Success caso o
        -:   18: * produto seja adicionado à lista com sucesso; Failure caso o produto já
        -:   19: * exista na lista; Illegal_argument, caso os parâmetros de produto passados
        -:   20: * sejam inválidos ou a função receba um ponteiro nulo como parâmetro.
        -:   21: *
        -:   22: * Adiciona um produto ao vetor do tipo product contido no tipo de dados
        -:   23: * productList alocando/realocando o vetor de produtos de list para conter uma
        -:   24: * entrada a mais e copiando os parâmetros de new_product para essa nova
        -:   25: * entrada.
        -:   26: *
        -:   27: * Importante: Aloca/Realoca dinamicamente o vetor que contém os produtos em
        -:   28: * list (uma estrutura de dados do tipo productList). Tal memória deve ser
        -:   29: * liberada no término do programa chamando-se a função CleanProductList(list)
        -:   30: * ou por meio da função free(list.items).
        -:   31: *
        -:   32: * Assertivas de entrada:
        -:   33: *  -Ambos new_product e list devem ser diferentes de NULL.
        -:   34: *  -O parâmetro new_product deve apontar para uma estrutura de dados do tipo
        -:   35: * product.
        -:   36: *  -O parâmetro list deve apontar para uma estrutura de dados do tipo
        -:   37: * productList.
        -:   38: *
        -:   39: * Assertivas de saída:
        -:   40: *  -O produto referenciado por new_product permanecerá inalterado e estará
        -:   41: * contido no vetor de produtos referenciada por list.
        -:   42: *
        -:   43: * Assertivas estruturais:
        -:   44: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:   45: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:   46: * para seu preço e um int para sua popularidade.
        -:   47: *  -Uma estrutura de dados productList possui um int para representar quantos
        -:   48: * produtos possui e um vetor de produtos que armazena os produtos em si.
        -:   49: *
        -:   50: * Assertivas de contrato:
        -:   51: *  -As informações contidas no endereço new_product serão copiadas para uma
        -:   52: * nova entrada na lista contida no endereço list.
        -:   53: *
        -:   54: * Requisitos:
        -:   55: *  -Uma estrutura de dados do tipo product alocada estaticamente.
        -:   56: *  -Uma estrutura de dados do tipo productList alocada estaticamente.
        -:   57: *
        -:   58: * Hipóteses:
        -:   59: *  -Sempre haverá espaço na heap para alocar ou realocar o vetor de produtos de
        -:   60: * list.
        -:   61: *
        -:   62: */
        -:   63:
       60:   64:errorLevel AddProduct(product *new_product, productList *list) {
        -:   65:
        -:   66:  int i, empty_slot;
        -:   67:
       60:   68:  if(new_product == NULL || list == NULL || !ValidProduct(new_product))
        8:   69:      return Illegal_argument;
        -:   70:
        -:   71:  /*
        -:   72:    Percorre-se a lista para verificar-se se o produto já não pertence à lista
        -:   73:    de produtos.
        -:   74:   */
        -:   75:
      114:   76:  for (i = 0; i < (list->size); ++i)
       64:   77:    if(!CompareProducts(&(list->items[i]), new_product))
        2:   78:      return Failure;
        -:   79:
        -:   80:  /*
        -:   81:    Caso o produto passado como argumento contenha campos válidos e ainda não
        -:   82:    pertença à lista, adiciona-se o produto à lista.
        -:   83:   */
        -:   84:
       50:   85:  list->size++; /* Aumenta-se o tamanho da lista devido à adição. */
        -:   86:
        -:   87:  /*
        -:   88:    Caso o produto adicionado seja o primeiro da lista, utiliza-se a função
        -:   89:    malloc para gerar o vetor de produtos. Do contrário, utiliza-se a função
        -:   90:    realloc para realocar o vetor de produtos.
        -:   91:   */
        -:   92:
       50:   93:  if(list->size == 1)
       22:   94:    list->items = (product*) malloc(sizeof(product));
        -:   95:
        -:   96:  else
       28:   97:    list->items = (product*) realloc(list->items, list->size * sizeof(product));
        -:   98:
       50:   99:  empty_slot = (list->size)-1; /* Posição vaga na lista. */
        -:  100:
       50:  101:  CopyProduct(&(list->items[empty_slot]), new_product);
        -:  102:
       50:  103:  return Success;
        -:  104:
        -:  105:}
        -:  106:
        -:  107:/**
        -:  108: * @fn errorLevel CleanProductList (productList *list)
        -:  109: * @brief Função para limpar uma lista de produtos.
        -:  110: * @param list Endereço da lista que será limpa. Argumento passado por
        -:  111: * referência.
        -:  112: * @return A função retorna uma instância do tipo errorLevel: Success caso a
        -:  113: * lista seja limpa com sucesso.
        -:  114: *
        -:  115: * Limpa uma estrutura de dados do tipo productList, desalocando seu vetor de
        -:  116: * estruturas de dados do tipo products e colocando o seu inteiro de tamanho
        -:  117: * como sendo igual a zero. Recomenda-se chama-la no início da execução de um
        -:  118: * programa para preparar a lista para uso e antes do término da execução do
        -:  119: * programa passando-se como argumento todas as listas de produtos usadas.
        -:  120: *
        -:  121: * Assertivas de entrada:
        -:  122: *  -O parâmetro list deve ser diferente de NULL.
        -:  123: *  -O parâmetro list deve apontar para uma estrutura de dados do tipo
        -:  124: * productList.
        -:  125: *
        -:  126: * Assertivas de saída:
        -:  127: *  -list->size = 0.
        -:  128: *  -list->items = NULL.
        -:  129: *
        -:  130: * Assertivas estruturais:
        -:  131: *  -Uma estrutura de dados productList possui um int para representar quantos
        -:  132: * produtos possui e um vetor de produtos que armazena os produtos em si.
        -:  133: *
        -:  134: * Assertivas de contrato:
        -:  135: *  -As informações contidas no endereço list serão limpas de forma que list se
        -:  136: * comporte como uma lista recém inicializada.
        -:  137: *
        -:  138: * Requisitos:
        -:  139: *  -Uma estrutura de dados do tipo productList alocada estaticamente.
        -:  140: *
        -:  141: * Hipóteses:
        -:  142: *  Nenhuma.
        -:  143: *
        -:  144: */
        -:  145:
       36:  146:errorLevel CleanProductList (productList *list) {
        -:  147:
        -:  148:  /*
        -:  149:    Para limpar uma lista de produtos, atribui-se ao seu tamanho o valor 0 e,
        -:  150:    caso seja necessário, libera-se o vetor de items alocado dinamicamente e
        -:  151:    atribui-se a ele o valor NULL.
        -:  152:   */
        -:  153:
       36:  154:  if(list == NULL)
        2:  155:    return Illegal_argument;
        -:  156:
       34:  157:  list->size = 0;
        -:  158:
       34:  159:  if(list->items != NULL) {
       18:  160:    free(list->items);
       18:  161:    list->items = NULL;
        -:  162:  }
        -:  163:
       34:  164:  return Success;
        -:  165:
        -:  166:}
        -:  167:
        -:  168:/**
        -:  169: * @fn errorLevel CreateSpecification(productType type, double min_price,
        -:  170: * double max_price, int min_popularity, int max_popularity,
        -:  171: * productSpecification *new_specification)
        -:  172: * @brief Função que cria uma especificação de busca.
        -:  173: * @param type Tipo do produto a ser procurado.
        -:  174: * @param min_price Preço mínimo do produto a ser procurado.
        -:  175: * @param max_price Preço máximo do produto a ser procurado.
        -:  176: * @param min_popularity Popularidade mínima do produto a ser procurado.
        -:  177: * @param max_popularity Popularidade máxima do produto a ser procurado.
        -:  178: * @param new_specification Endereço da estrutura de dados onde a especificação
        -:  179: * será criada. Argumento passado por referência.
        -:  180: * @return A função retorna uma instância do tipo errorLevel: Success caso a
        -:  181: * especificação seja criada com sucesso; Illegal_argument caso a função receba
        -:  182: * um ponteiro nulo como parâmetro.
        -:  183: *
        -:  184: * Copia os parâmetros fornecidos na função para o endereço da estrutura de
        -:  185: * dados do tipo productSpecification fornecida como parâmetro.
        -:  186: *
        -:  187: * Assertivas de entrada:
        -:  188: *  -O parâmetro new_specification deve ser diferente de NULL.
        -:  189: *  -O parâmetro new_specification deve apontar para uma estrutura de dados do
        -:  190: * tipo productSpecification.
        -:  191: *
        -:  192: * Assertivas de saída:
        -:  193: *  -Os membros da especificação no endereço new_specification serão aqueles
        -:  194: * passados como parâmetros para a função.
        -:  195: *
        -:  196: * Assertivas estruturais:
        -:  197: *  -Uma estrutura de dados productSpecification possui uma estrutura de dados
        -:  198: * do tipo productType para representar os tipos de produto desejados; dois
        -:  199: * doubles, um para representar o preço mínimo dos produtos desejados e outro
        -:  200: * para representar o preço máximo dos produtos desejados; e dois inteiros, um
        -:  201: * para representar a popularidade mínima dos produtos desejado e outro para
        -:  202: * representar a popularidade máxima dos produtos desejados.
        -:  203: *
        -:  204: * Assertivas de contrato:
        -:  205: *  -As informações contidas no endereço new_specification serão sobrescritas
        -:  206: * com aquelas fornecidas como parâmetros da função.
        -:  207: *
        -:  208: * Requisitos:
        -:  209: *  -Uma estrutura de dados do tipo productSpecification alocada estaticamente.
        -:  210: *
        -:  211: * Hipóteses:
        -:  212: *  Nenhuma.
        -:  213: *
        -:  214: */
        -:  215:
       16:  216:errorLevel CreateSpecification(
        -:  217:    productType type,
        -:  218:    double min_price,
        -:  219:    double max_price,
        -:  220:    int min_popularity,
        -:  221:    int max_popularity,
        -:  222:    productSpecification *new_specification) {
        -:  223:
       16:  224:  if(new_specification == NULL)
        2:  225:    return Illegal_argument;
        -:  226:
       14:  227:  new_specification->type = type;
       14:  228:  new_specification->minimum_price = min_price;
       14:  229:  new_specification->maximum_price = max_price;
       14:  230:  new_specification->minimum_popularity = min_popularity;
       14:  231:  new_specification->maximum_popularity = max_popularity;
        -:  232:
       14:  233:  return Success;
        -:  234:
        -:  235:}
        -:  236:
        -:  237:/**
        -:  238: * @fn errorLevel DeleteProduct (int index, productList *list)
        -:  239: * @brief Função que remove um produto de uma lista de produtos.
        -:  240: * @param index Índice do produto na lista de produtos.
        -:  241: * @param list Endereço da lista que terá o produto removido. Argumento passado
        -:  242: * por referência.
        -:  243: * @return A função retorna uma instância do tipo errorLevel: Success caso o
        -:  244: * produto seja removido da lista com sucesso; Illegal_argument, caso o índice
        -:  245: * passado como argumento seja inválido.
        -:  246: *
        -:  247: * Remove o produto contido no índice index da estrutura de dados do tipo
        -:  248: * productList referenciada por list. Caso esse seja o único produto da lista,
        -:  249: * o vetor de produtos da lista é liberado com free(). Do contrário, ele é
        -:  250: * realocado para ter uma posição a menos. Retornará Illegal_argument caso
        -:  251: * list->size = 0.
        -:  252: *
        -:  253: * Assertivas de entrada:
        -:  254: *  -O parâmetro list deve ser diferente de NULL.
        -:  255: *  -O parâmetro list deve apontar para uma estrutura de dados do tipo
        -:  256: * productList.
        -:  257: *  -O índice index deve ser um índice válido, considerando-se list->size.
        -:  258: *
        -:  259: * Assertivas de saída:
        -:  260: *  -list->size -= 1.
        -:  261: *  -O produto que estava no índice index de list->items não pertence mais a
        -:  262: * list->items.
        -:  263: *
        -:  264: * Assertivas estruturais:
        -:  265: *  -Uma estrutura de dados productList possui um int para representar quantos
        -:  266: * produtos possui e um vetor de produtos que armazena os produtos em si.
        -:  267: *
        -:  268: * Assertivas de contrato:
        -:  269: *  -O produto contido na posição index do vetor de produtos de list será
        -:  270: * removido do vetor de produtos de list.
        -:  271: *
        -:  272: * Requisitos:
        -:  273: *  -Uma estrutura de dados do tipo productList alocada estaticamente.
        -:  274: *
        -:  275: * Hipóteses:
        -:  276: *  -Sempre haverá espaço na heap para realocar o vetor de produtos de list.
        -:  277: *
        -:  278: */
        -:  279:
        8:  280:errorLevel DeleteProduct (int index, productList *list) {
        -:  281:
        -:  282:  int i;
        -:  283:
        8:  284:  if(list == NULL || !ValidIndex(index, list->size)) {
        4:  285:    return Illegal_argument;
        -:  286:  }
        -:  287:
        -:  288:  /*
        -:  289:    Caso a lista contenha apenas 1 item, libera-se o vetor de items e atribui-se
        -:  290:    a ele o valor NULL.
        -:  291:   */
        -:  292:
        4:  293:  else if(list->size == 1) {
        2:  294:    free(list->items);
        2:  295:    list->items = NULL;
        -:  296:  }
        -:  297:
        -:  298:  /* Caso contrário, o procedimento de deleção é mais complicado. */
        -:  299:
        -:  300:  else {
        -:  301:
        -:  302:    /*
        -:  303:      Primeiro, vamos "mover" todos os elementos do vetor de produtos que estão
        -:  304:      à direita do produto a ser removido uma "posição" para esquerda.
        -:  305:      Atingimos tal resultado sobrescrevendo o produto a ser removido com o
        -:  306:      produto que está a sua direita (o que pode ser feito com a função de
        -:  307:      copiar produtos) e repetindo esse procedimento até o penúltimo produto do
        -:  308:      vetor de produtos.
        -:  309:     */
        -:  310:
        4:  311:    for (i = index; i < list->size - 1; ++i)
        2:  312:      CopyProduct(&(list->items[i]), &(list->items[i + 1]));
        -:  313:
        -:  314:      /*
        -:  315:        Por fim, basta realocar a lista para que ela tenha um espaço a menos.
        -:  316:        Como o produto da última posição terá sido copiado para a penúltima
        -:  317:        posição, o produto que será "perdido" com o realocamento do vetor será
        -:  318:        aquele que deveria ser removido.
        -:  319:       */
        -:  320:
        2:  321:    list->items = (product*) realloc(list->items, (list->size - 1)
        -:  322:                                     * sizeof(product));
        -:  323:
        -:  324:  }
        -:  325:
        -:  326:  /*
        -:  327:    Após uma deleção bem sucedida, deve-se diminuir o tamanho da lista em uma
        -:  328:    unidade.
        -:  329:   */
        -:  330:
        4:  331:  (list->size) -= 1;
        -:  332:
        4:  333:  return Success;
        -:  334:
        -:  335:}
        -:  336:
        -:  337:/**
        -:  338: * @fn errorLevel SearchProduct(char query[75], productList *list,
        -:  339: * productSpecification *specifics, productList *matches)
        -:  340: * @brief Função que realiza a busca por um produto.
        -:  341: * @param query Nome ou parte de nome dos produtos procurados.
        -:  342: * @param list Endereço da lista onde a pesquisa de produtos será realizada.
        -:  343: * Argumento passado por referência.
        -:  344: * @param specifics Endereço da especificação de busca utilizada para busca.
        -:  345: * Argumento passado por referência.
        -:  346: * @param matches Endereço da lista de produtos onde os resultados serão
        -:  347: * armazenados. Argumento passado por referência.
        -:  348: * @return A função retorna uma instância do tipo errorLevel: Success caso a
        -:  349: * busca retorne algum resultado; Failure caso a busca não retorne resultados;
        -:  350: * Illegal_argument caso a função receba um ponteiro nulo como parâmetro.
        -:  351: *
        -:  352: * Busca por produtos no vetor de produtos de uma lista de produtos cujo nome
        -:  353: * contenha o trecho buscado passado como parâmetro da função e cujas
        -:  354: * especificações se adequem à especificação de produtos passada como parâmetro
        -:  355: * da função. Copia qualquer produto que se adeque ao cenário anterior à uma
        -:  356: * segunda lista de produtos passada como parâmetro da função para guardar os
        -:  357: * resultados da busca.
        -:  358: *
        -:  359: * Importante: Limpa os dados contidos na estrutura de dados referenciada por
        -:  360: * matches. Aloca/Realoca dinamicamente o vetor que contém os produtos em
        -:  361: * matches (uma estrutura de dados do tipo productList). Tal memória deve ser
        -:  362: * liberada no término do programa chamando-se a função
        -:  363: * CleanProductList(matches) ou por meio da função free(matches.items).
        -:  364: *
        -:  365: * Assertivas de entrada:
        -:  366: *  -Os parâmetros list, specifics e matches devem ser diferentes de NULL.
        -:  367: *  -O parâmetro list deve apontar para uma estrutura de dados do tipo
        -:  368: * productList.
        -:  369: *  -O parâmetro specifics deve apontar para uma estrutura de dados do tipo
        -:  370: * productSpecification.
        -:  371: *  -O parâmetro matches deve apontar para uma estrutura de dados do tipo
        -:  372: * productList.
        -:  373: *
        -:  374: * Assertivas de saída:
        -:  375: *  -Os produtos cujo nome continha ou se igualava à query, que se adequavam à
        -:  376: * especificação referenciada por specifics e que estavam no vetor de produtos
        -:  377: * de list estarão no vetor de produtos de matches.
        -:  378: *  -A estrutura de dados list permanecerá inalterada.
        -:  379: *  -Os dados da estrutra de dados matches serão sobrescritos pelos resultados
        -:  380: * da busca.
        -:  381: *
        -:  382: * Assertivas estruturais:
        -:  383: *  -Uma estrutura de dados productSpecification possui uma estrutura de dados
        -:  384: * do tipo productType para representar os tipos de produto desejados; dois
        -:  385: * doubles, um para representar o preço mínimo dos produtos desejados e outro
        -:  386: * para representar o preço máximo dos produtos desejados; e dois inteiros, um
        -:  387: * para representar a popularidade mínima dos produtos desejado e outro para
        -:  388: * representar a popularidade máxima dos produtos desejados.
        -:  389: *  -Uma estrutura de dados productList possui um int para representar quantos
        -:  390: * produtos possui e um vetor de produtos que armazena os produtos em si.
        -:  391: *
        -:  392: * Assertivas de contrato:
        -:  393: *  -Os produtos resultantes da busca feita em list com as especificações
        -:  394: * fornecidas sobrescreverão os produtos contidos no vetor de produtos
        -:  395: * referenciado por matches. O número de items em matches será igual ao número
        -:  396: * de resultados da busca.
        -:  397: *
        -:  398: * Requisitos:
        -:  399: *  -Uma estrutura de dados do tipo productSpecification alocada estaticamente.
        -:  400: *  -Duas estruturas de dados do tipo productList alocadas estaticamente.
        -:  401: *
        -:  402: * Hipóteses:
        -:  403: *  -Sempre haverá espaço na heap para alocar ou realocar o vetor de produtos de
        -:  404: * matches.
        -:  405: *
        -:  406: */
        -:  407:
       32:  408:errorLevel SearchProduct(char query[75], productList *list,
        -:  409:                          productSpecification *specifics,
        -:  410:                          productList *matches) {
        -:  411:
        -:  412:  int i;
        -:  413:
       32:  414:  if(specifics == NULL || list == NULL || matches == NULL)
       14:  415:    return Illegal_argument;
        -:  416:
        -:  417:  /*
        -:  418:    Deve-se limpar a lista de resultados da busca para evitar qualquer falso
        -:  419:    positivo.
        -:  420:   */
        -:  421:
       18:  422:  CleanProductList(matches);
        -:  423:
        -:  424:  /*
        -:  425:    Varre-se a lista de produtos procurando-se produtos cujo nome contenha a
        -:  426:    chave de busca e cujas características sejam permitidas pela especificação
        -:  427:    de busca. Caso encontre-se um produto que se encaixe nessa situação, ele
        -:  428:    é adicionado à lista de resultados.
        -:  429:   */
        -:  430:
       98:  431:  for (i = 0; i < (list->size); ++i) {
        -:  432:
      160:  433:    if((strstr(list->items[i].name, query) != NULL)
       80:  434:      && MatchesSpecification(&(list->items[i]), specifics)) {
        -:  435:
       28:  436:      AddProduct(&(list->items[i]), matches);
        -:  437:
        -:  438:    }
        -:  439:
        -:  440:  }
        -:  441:
       18:  442:  if(matches->size == 0)
        2:  443:    return Failure;
        -:  444:
        -:  445:  else
       16:  446:    return Success;
        -:  447:
        -:  448:}
        -:  449:
        -:  450:/**
        -:  451: * @fn errorLevel SelectProduct(int index, productList *list,
        -:  452: * product *selection)
        -:  453: * @brief Função que seleciona um produto de uma lista de produtos.
        -:  454: * @param index Índice do produto na lista de produtos.
        -:  455: * @param list Endereço da lista que contém o produto desejado. Argumento
        -:  456: * passado por referência.
        -:  457: * @param selection Endereço da estrutura de dados que reberá os parâmetros do
        -:  458: * produto desejado. Argumento passado por referência.
        -:  459: * @return A função retorna uma instância do tipo errorLevel: Success caso o
        -:  460: * produto seja selecionado com sucesso; Illegal_argument, caso o índice
        -:  461: * passado como argumento seja inválido ou seja fornecido um ponteiro nulo como
        -:  462: * parâmetro.
        -:  463: *
        -:  464: * Seleciona o produto de índice index no vetor de produtos de list para copiar
        -:  465: * suas informações para o produto referenciado por selection.
        -:  466: *
        -:  467: * Assertivas de entrada:
        -:  468: *  -Ambos selection e list devem ser diferentes de NULL.
        -:  469: *  -O parâmetro selection deve apontar para uma estrutura de dados do tipo
        -:  470: * product.
        -:  471: *  -O parâmetro list deve apontar para uma estrutura de dados do tipo
        -:  472: * productList.
        -:  473: *  -O índice index deve ser um índice válido, considerando-se list->size.
        -:  474: *
        -:  475: * Assertivas de saída:
        -:  476: *  -O produto referenciado por selection terá suas informações sobrescritas por
        -:  477: * aquelas do produto contido no índice index do vetor de produtos referenciada
        -:  478: * por list.
        -:  479: *  -A estrutura de dados list permanecerá inalterada.
        -:  480: *
        -:  481: * Assertivas estruturais:
        -:  482: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:  483: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:  484: * para seu preço e um int para sua popularidade.
        -:  485: *  -Uma estrutura de dados productList possui um int para representar quantos
        -:  486: * produtos possui e um vetor de produtos que armazena os produtos em si.
        -:  487: *
        -:  488: * Assertivas de contrato:
        -:  489: *  -Os membros do produto na posição index do vetor de produtos de list serão
        -:  490: * copiados para o produto referenciado por selection, sobrescrevendo seus
        -:  491: * membros antigos.
        -:  492: *
        -:  493: * Requisitos:
        -:  494: *  -Uma estrutura de dados do tipo product alocada estaticamente.
        -:  495: *  -Uma estrutura de dados do tipo productList alocada estaticamente.
        -:  496: *
        -:  497: * Hipóteses:
        -:  498: *  Nenhuma.
        -:  499: *
        -:  500: */
        -:  501:
       10:  502:errorLevel SelectProduct(int index, productList *list, product *selection) {
        -:  503:
       10:  504:  if(list == NULL || selection == NULL || !ValidIndex(index, list->size))
        8:  505:    return Illegal_argument;
        -:  506:
        2:  507:  CopyProduct(selection, &(list->items[index]));
        -:  508:
        2:  509:  return Success;
        -:  510:
        -:  511:}
        -:  512:
        -:  513:/**
        -:  514: * @fn MatchesSpecification(product *item, productSpecification *specification)
        -:  515: * @brief Função que verifica se um produto se adequa a uma especificação.
        -:  516: * @param item Endereço do produto a ser testado. Argumento passado por
        -:  517: * referência.
        -:  518: * @param specification Endereço da especificação na qual o produto é testado.
        -:  519: * Argumento passado por referência.
        -:  520: * @return A função retorna um inteiro: 1 se o produto se adequa à
        -:  521: * especificação; 0 se o produto não se adequa à especificação.
        -:  522: *
        -:  523: * Verifica se os membros type, price e popularity de um produto fornecido como
        -:  524: * parâmetro da função se adequam à especificação fornecida como parâmetro da
        -:  525: * função.
        -:  526: *
        -:  527: * Assertivas de entrada:
        -:  528: *  -Ambos item e specification devem ser diferentes de NULL.
        -:  529: *  -O parâmetro item deve apontar para uma estrutura de dados do tipo product.
        -:  530: *  -O parâmetro specification deve apontar para uma estrutura de dados do tipo
        -:  531: * productSpecification.
        -:  532: *
        -:  533: * Assertivas de saída:
        -:  534: *  -A estrutura de dados item permanecerá inalterada.
        -:  535: *  -A estrutura de dados specification permanecerá inalterada.
        -:  536: *
        -:  537: * Assertivas estruturais:
        -:  538: *  -Uma estrutura de dados product possui como membros um vetor de chars para
        -:  539: * seu nome, uma estrutura de dados do tipo productType para seu tipo, um double
        -:  540: * para seu preço e um int para sua popularidade.
        -:  541: *  -Uma estrutura de dados productSpecification possui uma estrutura de dados
        -:  542: * do tipo productType para representar os tipos de produto desejados; dois
        -:  543: * doubles, um para representar o preço mínimo dos produtos desejados e outro
        -:  544: * para representar o preço máximo dos produtos desejados; e dois inteiros, um
        -:  545: * para representar a popularidade mínima dos produtos desejado e outro para
        -:  546: * representar a popularidade máxima dos produtos desejados.
        -:  547: *
        -:  548: * Assertivas de contrato:
        -:  549: *  -A função retornará um inteiro representando se os parâmetros utilizados são
        -:  550: * válidos e se o produto passado como parâmetro se adequa à especificação
        -:  551: * passada como parâmetro.
        -:  552: *
        -:  553: * Requisitos:
        -:  554: *  -Uma estrutura de dados do tipo product alocada estaticamente.
        -:  555: *  -Uma estrutura de dados do tipo productSpecification alocada estaticamente.
        -:  556: *
        -:  557: * Hipóteses:
        -:  558: *  Nenhuma.
        -:  559: *
        -:  560: */
        -:  561:
       40:  562:int MatchesSpecification(product *item, productSpecification *specification) {
        -:  563:
       40:  564:  if(item == NULL || specification == NULL)
    #####:  565:    return -1;
        -:  566:
       40:  567:  else if((specification->type == All || specification->type == item->type)
       38:  568:    && (item->price >= specification->minimum_price
       36:  569:    && item->price <= specification->maximum_price)
       30:  570:    && (item->popularity >= specification->minimum_popularity
       28:  571:    && item->popularity <= specification->maximum_popularity))
       28:  572:    return 1;
        -:  573:
        -:  574:  else
       12:  575:    return 0;
        -:  576:
        -:  577:}
        -:  578:
        -:  579:/**
        -:  580: * @fn ValidIndex (int index, int list_size)
        -:  581: * @brief Função que verifica se um índice para um vetor é válido.
        -:  582: * @param index Índice testado.
        -:  583: * @param list_size Tamanho do vetor no qual o índice é testado.
        -:  584: * @return A função retorna um inteiro: 1 se o índice é válido; 0 se o índice é
        -:  585: * inválido.
        -:  586: *
        -:  587: * Verifica se um índice passado como parâmetro para função pode ser utilizado
        -:  588: * como índice válido para acessar um vetor cujo tamanho é fornecido como
        -:  589: * parâmetro.
        -:  590: *
        -:  591: * Assertivas de entrada:
        -:  592: *  Nenhuma.
        -:  593: *
        -:  594: * Assertivas de saída:
        -:  595: *  Nenhuma.
        -:  596: *
        -:  597: * Assertivas estruturais:
        -:  598: *  Nenhuma.
        -:  599: *
        -:  600: * Assertivas de contrato:
        -:  601: *  -A função retornará um inteiro representando se o índice fornecido pode ser
        -:  602: * utilizado para acessar um dos membros do vetor cujo tamanho é fornecido.
        -:  603: *
        -:  604: * Requisitos:
        -:  605: *  Nenhum.
        -:  606: *
        -:  607: * Hipóteses:
        -:  608: *  Nenhuma.
        -:  609: *
        -:  610: */
        -:  611:
       12:  612:int ValidIndex (int index, int list_size) {
        -:  613:
        -:  614:  /*
        -:  615:    Um índice deve ser positivo e menor que o tamanho da lista, pois, do
        -:  616:    contrário, ele acessaria uma área da memória fora do vetor da lista.
        -:  617:   */
        -:  618:
       12:  619:  if(index >= 0 && index < list_size)
        6:  620:    return 1;
        -:  621:
        -:  622:  else
        6:  623:    return 0;
        -:  624:
        -:  625:}
