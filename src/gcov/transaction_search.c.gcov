        -:    0:Source:transaction_search.c
        -:    0:Graph:transaction_search.gcno
        -:    0:Data:transaction_search.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:// Módulo de busca de transações.
        -:    2:
        -:    3:/**
        -:    4: * @file transaction_search.c
        -:    5: * @brief Implementação do módulo de busca de transações.
        -:    6: */
        -:    7:
        -:    8:#include "transaction_search.h"
        -:    9:
      103:   10:errorLevel AddTransaction(transaction *given_transaction,
        -:   11:                          transactionList *list) {
        -:   12:
        -:   13:  int i, empty_slot;
        -:   14:
      204:   15:  if(given_transaction == NULL || list == NULL
      203:   16:     || (ValidTransaction(given_transaction) != 1))
        6:   17:    return Illegal_argument;
        -:   18:
        -:   19:  /*
        -:   20:    Percorre-se a lista para verificar-se se a transação já não pertence à lista
        -:   21:    de transações.
        -:   22:   */
        -:   23:
      271:   24:  for (i = 0; i < (list->size); ++i)
      175:   25:    if(!CompareTransactions(&(list->items[i]), given_transaction))
        1:   26:      return Failure;
        -:   27:
        -:   28:  /*
        -:   29:    Caso a transação passada como argumento contenha campos válidos e ainda não
        -:   30:    pertença à lista, adiciona-se a transação à lista.
        -:   31:   */
        -:   32:
       96:   33:  list->size++; /* Aumenta-se o tamanho da lista devido à adição. */
        -:   34:
        -:   35:  /*
        -:   36:    Caso a transação adicionada seja a primeira da lista, utiliza-se a função
        -:   37:    malloc para gerar o vetor de transações. Do contrário, utiliza-se a função
        -:   38:    realloc para realocar o vetor de transações.
        -:   39:   */
        -:   40:
       96:   41:  if(list->size == 1)
       27:   42:    list->items = (transaction*) malloc(sizeof(transaction));
        -:   43:
        -:   44:  else
       69:   45:    list->items = (transaction*) realloc(list->items,
       69:   46:                                         list->size * sizeof(transaction));
        -:   47:
       96:   48:  empty_slot = (list->size)-1; /* Posição vaga na lista. */
        -:   49:
       96:   50:  CopyTransaction(&(list->items[empty_slot]), given_transaction);
        -:   51:
       96:   52:  return Success;
        -:   53:
        -:   54:}
        -:   55:
       48:   56:errorLevel CleanTransactionList(transactionList *list) {
        -:   57:
        -:   58:  /*
        -:   59:    Para limpar uma lista de transações, atribui-se ao seu tamanho o valor 0 e,
        -:   60:    caso seja necessário, libera-se o vetor de items alocado dinamicamente e
        -:   61:    atribui-se a ele o valor NULL.
        -:   62:   */
        -:   63:
       48:   64:  if(list == NULL)
        1:   65:    return Illegal_argument;
        -:   66:
       47:   67:  list->size = 0;
        -:   68:
       47:   69:  if(list->items != NULL) {
       27:   70:    free(list->items);
       27:   71:    list->items = NULL;
        -:   72:  }
        -:   73:
       47:   74:  return Success;
        -:   75:
        -:   76:}
        -:   77:
        8:   78:errorLevel CreateRestriction(relationship proximity, double min_rating,
        -:   79:                             double max_rating, userRestriction *restriction) {
        -:   80:
        8:   81:  if(restriction == NULL)
        1:   82:    return Illegal_argument;
        -:   83:
        7:   84:  restriction->proximity = proximity;
        7:   85:  restriction->minimum_rating = min_rating;
        7:   86:  restriction->maximum_rating = max_rating;
        -:   87:
        7:   88:  return Success;
        -:   89:
        -:   90:}
        -:   91:
        3:   92:errorLevel DeleteTransaction (int index, transactionList *list) {
        -:   93:
        -:   94:  int i;
        -:   95:
        3:   96:  if(list == NULL || !ValidIndex(index, list->size)) {
        2:   97:    return Illegal_argument;
        -:   98:  }
        -:   99:
        -:  100:  /*
        -:  101:    Caso a lista contenha apenas 1 item, libera-se o vetor de items e atribui-se
        -:  102:    a ele o valor NULL.
        -:  103:   */
        -:  104:
        1:  105:  else if(list->size == 1) {
    #####:  106:    free(list->items);
    #####:  107:    list->items = NULL;
        -:  108:  }
        -:  109:
        -:  110:  /* Caso contrário, o procedimento de deleção é mais complicado. */
        -:  111:
        -:  112:  else {
        -:  113:
        -:  114:    /*
        -:  115:      Primeiro, vamos "mover" todos os elementos do vetor de transações que
        -:  116:      estão à direita da transação a ser removida uma "posição" para esquerda.
        -:  117:      Atingimos tal resultado sobrescrevendo a transação a ser removida com a
        -:  118:      transação que está a sua direita (o que pode ser feito com a função de
        -:  119:      copiar transações) e repetindo esse procedimento até a penúltima transação
        -:  120:      do vetor de transações.
        -:  121:     */
        -:  122:
        2:  123:    for (i = index; i < list->size - 1; ++i)
        1:  124:      CopyTransaction(&(list->items[i]), &(list->items[i + 1]));
        -:  125:
        -:  126:    /*
        -:  127:      Por fim, basta realocar a lista para que ela tenha um espaço a menos.
        -:  128:      Como a transação da última posição terá sido copiado para a penúltima
        -:  129:      posição, a transação que será "perdida" com o realocamento do vetor será
        -:  130:      aquela que deveria ser removida.
        -:  131:     */
        -:  132:
        1:  133:    list->items = (transaction*) realloc(list->items, (list->size - 1)
        -:  134:                                     * sizeof(transaction));
        -:  135:
        -:  136:  }
        -:  137:
        -:  138:  /*
        -:  139:    Após uma deleção bem sucedida, deve-se diminuir o tamanho da lista em uma
        -:  140:    unidade.
        -:  141:   */
        -:  142:
        1:  143:  (list->size) -= 1;
        -:  144:
        1:  145:  return Success;
        -:  146:
        -:  147:}
        -:  148:
        3:  149:errorLevel LoadTransactionList(transactionList *list) {
        -:  150:
        -:  151:  FILE *fp;
        -:  152:  transaction new_transaction;
        -:  153:  product item;
        -:  154:  char name[75];
        -:  155:  productType type;
        -:  156:  double price;
        -:  157:  int popularity, auxiliary1, auxiliary2;
        -:  158:  unsigned int user1, user2;
        -:  159:  transactionStatus status;
        -:  160:
        3:  161:  if(list == NULL)
        1:  162:    return Illegal_argument;
        -:  163:
        -:  164:  /*
        -:  165:    Caso não seja possível abrir o banco de dados para transações, a função
        -:  166:    falha.
        -:  167:   */
        -:  168:
        2:  169:  fp = fopen(TRANSACTION_DB, "r");
        -:  170:
        2:  171:  if(fp == NULL)
    #####:  172:    return Failure;
        -:  173:
        -:  174:  /* Limpa-se a lista para eliminar qualquer transação residual. */
        -:  175:
        2:  176:  CleanTransactionList(list);
        -:  177:
        -:  178:  /*
        -:  179:    Enquanto o arquivo não chegar ao fim, os dados de uma transação são
        -:  180:    carregados em váriaveis intermediárias que serão utilizadas para criar
        -:  181:    primeiramente o produto da transação e depois a transação em si. Note
        -:  182:    que a enumeração productType de cada produto e a enumeração
        -:  183:    transactionStatus de cada transação foram, ambos, gravados como ints, então
        -:  184:    devemos convertê-los para o tipo productType e transactionStatus,
        -:  185:    respectivamente.
        -:  186:   */
        -:  187:
       30:  188:  while(fscanf(fp, "%u|%u|%[^|]|%d|%lf|%d|%d\n", &user1, &user2, name,
       16:  189:        &auxiliary1, &price, &popularity, &auxiliary2) != EOF) {
        -:  190:
       28:  191:    if(ConvertIntToProductType(auxiliary1, &type) == 0
       14:  192:       && ConvertIntToTransactionStatus(auxiliary2, &status) == 0) {
        -:  193:
       14:  194:      if(CreateProduct(name, type, price, popularity, &item) == Success)
       28:  195:        if(CreateTransaction(user1, user2, &item, status, &new_transaction)
       14:  196:           == Success)
       14:  197:          AddTransaction(&new_transaction, list);
        -:  198:
        -:  199:    }
        -:  200:
        -:  201:  }
        -:  202:
        2:  203:  fclose(fp);
        -:  204:
        2:  205:  return Success;
        -:  206:
        -:  207:}
        -:  208:
       13:  209:errorLevel OpenTransactions(
        -:  210:    unsigned int search_author,
        -:  211:    product *given_product,
        -:  212:    userRestriction *restriction,
        -:  213:    transactionList *list,
        -:  214:    transactionList *matches) {
        -:  215:
        -:  216:  int i;
        -:  217:
       24:  218:  if(restriction == NULL || list == NULL || matches == NULL ||
       21:  219:     given_product == NULL || (ValidProduct(given_product) != 1))
        6:  220:    return Illegal_argument;
        -:  221:
        -:  222:  /*
        -:  223:    Deve-se limpar a lista de resultados da busca para evitar qualquer transação
        -:  224:    residual.
        -:  225:   */
        -:  226:
        7:  227:  CleanTransactionList(matches);
        -:  228:
       43:  229:  for (i = 0; i < (list->size); ++i) {
        -:  230:
       72:  231:    if(list->items[i].status == Open
       24:  232:       && !CompareProducts(&(list->items[i].item), given_product)
       53:  233:       && (MatchesRestriction(search_author, list->items[i].user1, restriction)
        -:  234:       == 1)) {
        -:  235:
       12:  236:      AddTransaction(&(list->items[i]), matches);
        -:  237:
        -:  238:    }
        -:  239:
        -:  240:  }
        -:  241:
        7:  242:  if(matches->size == 0)
        2:  243:    return Failure;
        -:  244:
        -:  245:  else
        5:  246:    return Success;
        -:  247:
        -:  248:}
        -:  249:
        8:  250:errorLevel ProductTransactions(product *given_product, transactionList *list,
        -:  251:                               transactionList *matches) {
        -:  252:
        -:  253:  int i;
        -:  254:
       12:  255:  if(given_product == NULL || list == NULL || matches == NULL ||
        4:  256:     (ValidProduct(given_product) != 1))
        5:  257:    return Illegal_argument;
        -:  258:
        -:  259:  /*
        -:  260:    Deve-se limpar a lista de resultados da busca para evitar qualquer transação
        -:  261:    residual.
        -:  262:   */
        -:  263:
        3:  264:  CleanTransactionList(matches);
        -:  265:
       12:  266:  for (i = 0; i < (list->size); ++i)
        9:  267:    if(!CompareProducts(&(list->items[i].item), given_product))
        3:  268:      AddTransaction(&(list->items[i]), matches);
        -:  269:
        3:  270:  if(matches->size == 0)
        2:  271:    return Failure;
        -:  272:
        -:  273:  else
        1:  274:    return Success;
        -:  275:
        -:  276:}
        -:  277:
        2:  278:errorLevel SaveTransactionList(transactionList *list) {
        -:  279:
        -:  280:  FILE *fp;
        -:  281:  int i;
        -:  282:
        2:  283:  if(list == NULL)
        1:  284:    return Illegal_argument;
        -:  285:
        -:  286:  /*
        -:  287:    Caso não seja possível abrir o banco de dados para transações, a função
        -:  288:    falha.
        -:  289:   */
        -:  290:
        1:  291:  fp = fopen(TRANSACTION_DB, "w");
        -:  292:
        1:  293:  if(fp == NULL)
    #####:  294:    return Failure;
        -:  295:
        -:  296:  /*
        -:  297:    Grava-se os dados das transações separando-se os campos de uma mesma
        -:  298:    transação pelo caractere reservado '|' e separando-se transações diferentes
        -:  299:    pelo caractere '\n'. Para gravar-se os dados do produto contido na
        -:  300:    transação, grava-se cada um de seus campos, separando-os, novamente, pelo
        -:  301:    caractere '|'. Note que as enumerações productType e transactionStatus são
        -:  302:    gravadas como ints.
        -:  303:   */
        -:  304:
        8:  305:  for (i = 0; i < list->size; i++)
       42:  306:    fprintf(fp, "%u|%u|%s|%d|%lf|%d|%d\n", list->items[i].user1,
       14:  307:            list->items[i].user2, list->items[i].item.name,
       14:  308:            list->items[i].item.type, list->items[i].item.price,
       14:  309:            list->items[i].item.popularity, list->items[i].status);
        -:  310:
        1:  311:  fclose(fp);
        -:  312:
        1:  313:  return Success;
        -:  314:
        -:  315:}
        -:  316:
        5:  317:errorLevel SelectTransaction(int index, transactionList *list,
        -:  318:                             transaction *selection) {
        -:  319:
        5:  320:  if(list == NULL || selection == NULL || !ValidIndex(index, list->size))
        4:  321:    return Illegal_argument;
        -:  322:
        1:  323:  CopyTransaction(selection, &(list->items[index]));
        -:  324:
        1:  325:  return Success;
        -:  326:
        -:  327:}
        -:  328:
        7:  329:errorLevel StatusTransactions(transactionStatus status, transactionList *list,
        -:  330:                              transactionList *matches) {
        -:  331:
        -:  332:  int i;
        -:  333:
        7:  334:  if(list == NULL || matches == NULL || status == Error)
        4:  335:    return Illegal_argument;
        -:  336:
        -:  337:  /*
        -:  338:    Deve-se limpar a lista de resultados da busca para evitar qualquer transação
        -:  339:    residual.
        -:  340:   */
        -:  341:
        3:  342:  CleanTransactionList(matches);
        -:  343:
       12:  344:  for (i = 0; i < (list->size); ++i)
        9:  345:    if(status == list->items[i].status)
        2:  346:      AddTransaction(&(list->items[i]), matches);
        -:  347:
        3:  348:  if(matches->size == 0)
        2:  349:    return Failure;
        -:  350:
        -:  351:  else
        1:  352:    return Success;
        -:  353:
        -:  354:}
        -:  355:
        7:  356:errorLevel UserTransactions(unsigned int user, transactionList *list,
        -:  357:                            transactionList *matches) {
        -:  358:
        -:  359:  int i;
        -:  360:
        7:  361:  if(list == NULL || matches == NULL || user == 0)
        4:  362:    return Illegal_argument;
        -:  363:
        -:  364:  /*
        -:  365:    Deve-se limpar a lista de resultados da busca para evitar qualquer transação
        -:  366:    residual.
        -:  367:   */
        -:  368:
        3:  369:  CleanTransactionList(matches);
        -:  370:
       12:  371:  for (i = 0; i < (list->size); ++i)
        9:  372:    if(user == list->items[i].user1 || user == list->items[i].user2)
        3:  373:      AddTransaction(&(list->items[i]), matches);
        -:  374:
        3:  375:  if(matches->size == 0)
        2:  376:    return Failure;
        -:  377:
        -:  378:  else
        1:  379:    return Success;
        -:  380:
        -:  381:}
        -:  382:
       17:  383:int MatchesRestriction(unsigned int original_user, unsigned int given_user,
        -:  384:                       userRestriction *restriction) {
        -:  385:
        -:  386:  double rating;
       17:  387:  int result = 0;
        -:  388:  unsigned int i;
        -:  389:  usuarios_uintarray friends, friends_of_friends;
        -:  390:  relationship proximity;
        -:  391:
        -:  392:  /*
        -:  393:    Caso argumentos passados para a função sejam inválidos ou não seja possível
        -:  394:    carregar as avaliações de cada usuário, a função retorna -1. Note que o id
        -:  395:    de usuário 0 está reservado para o usuário da sessão, sendo, assim, um
        -:  396:    argumento ilegal.
        -:  397:   */
        -:  398:
       34:  399:  if(restriction == NULL || original_user == 0 || given_user == 0
       34:  400:     || (usuarios_retornaDados(given_user, "avaliacao", &rating)
        -:  401:     != USUARIOS_SUCESSO)) {
    #####:  402:    return -1;
        -:  403:  }
        -:  404:
        -:  405:  /*
        -:  406:    Caso a avaliação do usuário não se adeque às restrições, a função retorna 0.
        -:  407:    Do contrário, devemos avaliar se a proximidade dos usuários é compatível com
        -:  408:    a restrição imposta.
        -:  409:   */
        -:  410:
       17:  411:  else if(rating > restriction->maximum_rating
       16:  412:          || rating < restriction->minimum_rating) {
        2:  413:    return 0;
        -:  414:  }
        -:  415:
        -:  416:  else {
        -:  417:
        -:  418:    /*
        -:  419:      A restrição de proximidade "Other" aceita qualquer usuário. Como já
        -:  420:      checamos a avaliação do usuário inspecionado, então podemos concluir que
        -:  421:      ele se encaixa na restrição.
        -:  422:     */
        -:  423:
       15:  424:    if(restriction->proximity == Other){
        9:  425:      return 1;
        -:  426:    }
        -:  427:
        -:  428:    /*
        -:  429:        Caso a restrição de proximidade seja diferente de "Other", devemos
        -:  430:      analisar as lista de amigos e de amigos de amigos do usuário inspecionado.
        -:  431:      Caso não seja possível carregar as listas de amigos e de amigos de amigos
        -:  432:      do usuário inspecionado, a função retornará -1.
        -:  433:        Note que as listas poderiam ter sido carregadas no início da função,
        -:  434:      mas, tendo-se em vista que carregar as referidas listas é um processo
        -:  435:      custoso em relação aos outros processos da função, a função foi
        -:  436:      estruturada de forma a evitar esse processo sempre que possível.
        -:  437:        Note também que, a partir deste ponto, deveremos liberar as listas de
        -:  438:      amigos e de amigos de amigos do usuário inspecionado independentemente do
        -:  439:      resultado da função. Portanto, optou-se por armazenar o resultado da
        -:  440:      função em uma variável intermediária "result" e, ao final da função,
        -:  441:      liberar as referidas listas e retornar "result" para evitar a repetição
        -:  442:      do código de liberação das listas.
        -:  443:     */
        -:  444:
       12:  445:    else if((usuarios_listarAmigos(given_user, &friends) != USUARIOS_SUCESSO)
        6:  446:            || (usuarios_listarAmigosdeAmigos(given_user, &friends_of_friends)
        -:  447:            != USUARIOS_SUCESSO)) {
    #####:  448:      result = -1;
        -:  449:    }
        -:  450:
        -:  451:
        -:  452:    else {
        -:  453:
        -:  454:      /* Inicialmente, considera-se o usuário inspecionado um estranho. */
        -:  455:
        6:  456:      proximity = Other;
        -:  457:
      206:  458:      for(i = 0; i < friends.length; i++)
      200:  459:        if(friends.array[i] == original_user)
        2:  460:          proximity = Friend;
        -:  461:
        -:  462:      /*
        -:  463:        Caso o usuário inspecionado seja amigo do usuário original, ele
        -:  464:        adequa-se tanto à restrição de proximidade "Friend" quanto à restrição
        -:  465:        de proximidade "FriendOfFriend".
        -:  466:       */
        -:  467:
        6:  468:      if((restriction->proximity == Friend
        3:  469:         || restriction->proximity == FriendOfFriend) && proximity == Friend) {
        2:  470:        result = 1;
        -:  471:      }
        -:  472:
      202:  473:      for(i = 0; i < friends_of_friends.length; i++)
      196:  474:        if(friends_of_friends.array[i] == original_user)
        2:  475:          proximity = FriendOfFriend;
        -:  476:
        -:  477:      /*
        -:  478:        Caso o usuário inspecionado seja amigo de um amigo do usuário original,
        -:  479:        ele adequa-se apenas à restrição de proximidade "FriendOfFriend".
        -:  480:       */
        -:  481:
        6:  482:      if(restriction->proximity == FriendOfFriend
        3:  483:         && proximity == FriendOfFriend) {
        1:  484:        result = 1;
        -:  485:      }
        -:  486:
        -:  487:    }
        -:  488:
        6:  489:    usuarios_freeUint(&friends);
        6:  490:    usuarios_freeUint(&friends_of_friends);
        6:  491:    return result;
        -:  492:
        -:  493:  }
        -:  494:
        -:  495:}
